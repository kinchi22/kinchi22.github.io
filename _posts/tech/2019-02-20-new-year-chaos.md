---
layout: post
title: "Hackerrank:New Year Chaos 문제풀이"
author: sk
teaser: 요즘 해커랭크에서 알고리즘 문제를 파이썬으로 푸는 재미에 푹 빠졌다. 파이썬의 간결함과 강력한 표준 라이브러리, 높은 생산성에 감탄하며 간단한 알고리즘 문제들을 척척 처리하던 중, 처음으로 timeout 실패를 맛보게 해준 문제가 있었다. 그래서 그 문제의 해결 과정을 기록에 남기려 한다.
categories:
  - algorithm
  - python
  - hackerrank
tags:
  - Hackerrank
  - New Year Chaos
image: assets/images/programming/money.jpg
caption: Photo by A L L E F . V I N I C I U S Δ
caption_url: https://unsplash.com/photos/fJTqyZMOh18
---
요즘 해커랭크에서 알고리즘 문제를 파이썬으로 푸는 재미에 푹 빠졌다. 파이썬의 간결함과 강력한 표준 라이브러리, 높은 생산성에 감탄하며 간단한 알고리즘 문제들을 척척 해결해 나가던 중, 처음으로 timeout 실패를 맛보게 해준 문제가 있었다. 그래서 그 문제의 해결 과정을 기록에 남기려 한다.

## Problem
[문제 링크][1]

New Year Chaos라는 재미있는 제목을 가지고 있지만, 내용은 간단하다.

각자 자신이 자신이 가지고 있는 순번이 있지만, 뇌물을 이용해 앞으로 나아갈 수 있으며, 한 사람당 최대 2번까지 앞으로 나아갈 수 있다.
테스트 케이스에서 주어진 번호의 나열을 보고, 원래의 순번에서 몇 번의 뇌물이 사용되었는지를 알아내는 문제이다. 만약 테스트 케이스를 만들기 위해 한 사람이 3번 이상의 뇌물을 사용해야 하는 경우라면, "너무 무질서하다"고 답하면 된다.

## Implementation
알고리즘 문제가 문제로써 재미있어지려면 기본적으로 시간 복잡도를 고려하고 있어야 한다.
이 문제도 그러하다. 10<sup>3</sup> 이하의 수에 대한 해결은 60%의 점수만을 얻을 수 있고, 10<sup>5</sup> 까지 모두 정해진 시간 내에 해결할 수 있을 때에 비로소 100%의 점수를 모두 얻을 수 있다.

### 1st try
이전까지 풀어온 문제에서 어려움을 느끼지 못했기 때문에, 나는 이번 문제도 아무렇지 않게 해결에 들어갔다.

가장 앞자리부터 탐색을 하면서, 현재 수가 원래의 수보다 2를 초과한 차이를 보인 경우에는 뇌물을 3번 이상 사용했다는 것을 의미하므로 'Too chaotic'을 출력하고 함수를 종료한다.

그리고 현재 자리의 뒤에 위치하는 수들과 하나씩 비교하면서, 뒷 자리에 자신보다 작은 수가 존재하면 뇌물의 횟수를 하나씩 증가 시켜주도록 하였다.

다음은 내가 이 문제의 답으로 제출한 첫 번째 코드이다.
```py
def minimumBribes(q):
    bribes = 0
    for i, p in enumerate(q, 1):
        if p - i > 2:
            print('Too chaotic')
            return
        for j in range(i, len(q)):
            if p > q[j]:
                bribes += 1

    print(bribes)
```
위 코드의 시간 복잡도는 O(N<sup>2</sup>)이다. 어찌 보면 당연하게도, 11개의 테스트 케이스 중 7개만 통과하여 40점 만점에 22점의 점수만을 얻을 수 있었다.

### 2nd try
여기에서 어떻게 하면 시간을 더 줄일 수 있을 지 짧게 고민했다. 어떻게 하면 모든 경우에서 자신보다 뒤에 있는 모든 수를 탐색하지 않을 수 있을까.

자신의 원래 위치보다 앞선 자리에 있다면 그 수는 뇌물을 준 것이 틀림없다. 그 경우엔 자신의 원래 자리와의 갭이 곧 뇌물을 준 횟수와 같아질 것이다. 이 경우에는 바로 뇌물 횟수를 세고, 다음 자리의 수로 넘어갈 수 있다.

그리고 만약 i번째에 위치하고 있는 수 보다 뒤에 위치한 수 중에 가장 작은 수가 i번째에 위치한 수보다 작은 경우가 존재한다면, 그것은 i번째 위치한 수가 뇌물을 사용했다는 것을 의미한다. 따라서 나는 i번째 위치한 수의 뒤쪽에 있는 모든 수들과 하나하나 값을 비교하는 로직을 최소값과 비교하는 로직으로 변경하였다.

```py
def minimumBribes(q):
    bribes = 0
    for i, p in enumerate(q, 1):
        if p - i > 2:
            print('Too chaotic')
            return
        elif p - i > 0:
            bribes += p - i
            continue
        if i < len(q):
            r_min = min(q[i:])
            if p > r_min:
                bribes += 1

    print(bribes)
```
결과는 달라지지 않았다. 이번 시도에서도 11개의 테스트 케이스 중 7개만 통과해 동일한 점수를 얻었다.  
안일하기 짝이 없는 시도였다. 아무리 몇 개의 경우에서 다음으로 빠르게 넘어갈 수 있다고 하더라도, 최소값을 구하는 데에 드는 시간 복잡도는 O(N)이기 때문에 위 로직의 시간 복잡도는 O(N<sup>2</sup>)이 되어 버린다.

### 3rd try
위와 같은 방법과는 근본부터 다른 접근 방법이 필요했다.

위의 두 번째 접근에서도 언급하였듯이, 자신보다 뒤에 있는 수들 중 자신보다 작은 수가 있다는 것이 곧 뇌물을 사용했다는 것을 의미한다는 것을 알아냈다.
그렇다면 현재 자리의 수 보다 뒤에 있는 수들 중의 최소값을 매번 구하지 않을 방법은 무엇이 있을까?

답은 간단했다. 앞자리부터 체크하지 않고, 뒷자리부터 체크하며 최소값을 계속 갱신하면 되는 것이다.

최대 2번까지 뇌물을 줄 수 있기 때문에, 현 자리까지의 최소값과, 두 번째로 작은 값을 저장하는 변수 `smallest`를 만들었다. 그리고 파이썬 빌트인 함수인 `reversed()`를 이용해 역순으로 탐색을 시작한다.
> 이 부분에서 파이썬을 사용할 때 주의해야할 점이 있다. 간단히 리스트의 stride를 음수로 지정(`q[::-1]`)하여 역순으로 탐색하는 것이 가능하다. 하지만 이것은 데이터의 shallow copy를 생성하기 때문에 메모리의 낭비가 발생한다. 따라서 shallow copy를 생성하지 않는 `reversed()` 함수를 이용하는 것을 추천한다.

만약 현재 자리의 수를 뒷 자리의 수들 중 두 번째 작은 값까지 모두 비교했을 때 더 크다면, 해당 수는 뇌물을 두 번 모두 사용한 것이 된다. 최소값보다는 크고, 두 번째로 작은 값보다는 작을 때에는 뇌물을 한 번만 쓴 것을 의미한다.

한 자리의 수에 대한 처리를 하면서 동시에 이전까지의 최소값 및 두 번째 작은 값과 비교하여 두 최소값을 갱신한다. 이렇게 함으로써 각 수 당 2개 값과의 비교만으로 최소값을 계속 갱신하는 것이 가능하다.
```py
def minimumBribes(q):
    bribes = 0
    smallest = [sys.maxsize, sys.maxsize]

    for i, p in reversed(list(enumerate(q, 1))):
        if p - i > 2:
            print('Too chaotic')
            return
        elif p > smallest[1]:
            bribes += 2
        elif p > smallest[0]:
            bribes += 1

        if p < smallest[0]:
            smallest = (p, smallest[0])
        elif p < smallest[1]:
            smallest = (smallest[0], p)

    print(bribes)
```
위의 구현으로 11개 테스트 케이스를 모두 통과하는 것이 가능했다. 모든 자리의 수를 탐색하면서, 최소값을 구하는데에 O(1)의 시간 복잡도를 가지므로 위 로직의 시간 복잡도는 O(N)이 되었다.  
뿐만 아니라 최소값을 저장하는 메모리 또한 2개의 정수 값을 저장하는 공간만이 필요하게 되므로, 공간 복잡도는 O(1)이다.

[1]: https://www.hackerrank.com/challenges/new-year-chaos/problem
