{"pages":[{"title":"About Seulki Bae","text":"Intro.현재 도쿄에 거주하며 서버사이드 엔지니어로 근무하고 있습니다. 공식 문서, 베스트 프랙티스에 집착하고 있으며 꾸준히 실력을 늘리려 노력하고 있습니다. Github LinkedIn Email","link":"/about.html"}],"posts":[{"title":"프로타고라스 - 플라톤/범우","text":"요즘 뉴​스에서 군대에 관한 이야기를 많이 접한다. 자잘하지만 지속적으로 발생하는 병영생활 행동강령 위반사례들부터 오랫동안 큰 이슈였던 총기사건이나 폭행으로 인한 사망사건까지, 나도 군대를 다녀왔기 때문인지 군에 관한 소식들은 다른 사건들보다 더욱 내 마음 한구석을 답답하게 했다. 도대체 왜 이런 사건들이 발생하는 것일까라는 표면적 의구심에서 인간의 도덕성과 정의, 양심 따위의 것들까지 곰곰히 생각하던 중에 프로타고라스가 눈에 들어왔다. 프로타고라스는 플라톤 ‘대화편’의 하나로, 소크라테스와 프로타고라스의 논쟁이 서술되어 있다. 지,덕,선에 대해 펼친 논쟁을 기록한 책이며 주요 논점으로 덕이란 무엇이며 어떻게 구성되어 있는가, 덕은 지식을 통해 획득될 수 있는가 등이 거론되어 있다. 전문기술과는 다르게 인간은 본래 모든 사람이 정의와 덕성을 나누어 가지고 있다고 프로타고라스는 얘기했다. 모두가 나누어 가지고 있음에도 왜 우리 사회에는 정의에 반하는 일들이 발생하는 것일까. 덕이라는 것이 얼굴 생김새나 키처럼 타고나는 것이라면 덕성에 거슬리는 행동을 쉽게 책망하기는 어려울 것이다. 하지만 우리는 위와 같은 행동들에 거부감을 느끼고, 징계를 원하기도 한다. 이는 우리가 덕성이라는 것이 마음가짐과 배움으로 얻어질 수 있는 것이라고 생각하기 때문이다. 옳지 못한 행동에 대한 징계의 목적은 미래에 있다고 한다. 이 말을 듣고 나는 부끄러움을 느꼈다. 죄를 지었으면 그에 합당한 벌을 받아야 한다고 생각해왔다. 징계에 대한 의미를 그동안 모르면서도 생각조차 해보지 않은 것이다. 징계를 함으로써 미래에 이와 같은 행동을 하지 않도록 하고, 당사자 뿐 아니라 관찰하는 사람에게도 덕이 무엇인지 느끼고 배울 수 있도록 하는 것임을 이제야 알게 됐다. 덕은 지혜와 분별과 용기와 정의와 경건 같은 것으로 구성되어 있다. 이 중에서 지혜는 다른 것의 지배를 받지 않으며, 지혜와 지식이 가장 우월한 위치에서 사람을 지배할 수 있다고 말한다. 소크라테스는 사물에 대한 두려움 등은 그에 대한 무지 때문이라고 주장했다. 또한 우리가 선과 악 양자의 선택에서 오류를 범하는 것은 그 선택에 대한 무지에서 비롯한다는 것이다. 즉, 우리는 지식이 없으면 덕의 구성요소 중 많은 것을 얻을 수 없기 때문에 끊임없이 배워야 한다. 반박의 여지가 없어 보이는 서로의 주장에 끊임없이 반박하면서도 쉬이 모순이 발견되지 않는 현인들의 대화를 통해 획일화되고 비평하지 못하는 사고를 벗어나 적극적이고 주체적인 사고를 발견하게 된다. 서로의 어긋나는 의견이 대화를 통해 해결점이나 타협점을 찾아 가장 논리적인 결론으로 나아가는 것을 보며 자신의 의견을 타인과 나누고 조율하며 가장 올바른 길을 선택하는 것이 중요함을 깨닫게 되었다. 스탈린과 히틀러는 독서를 정말 많이 한 사람들이었다고 한다. 하지만 본인이 습득한 지식을 혼자서 취사선택하고 흡수해 잘못된 길을 가게 됐다는 것이다. 두 사람이 함께 길을 가노라면 적어도 한 사람은 길을 잘 분별할 수 있다. 본 책에서 소크라테스가 인용한 호메로스의 말이다. 우리 모두가 사람의 덕성에 대해 고찰하고 지식을 습득하며, 그 지식과 생각을 나눌 수 있는 친구가 있다면 우리의 심기를 불편하게 하는 사건들이 적어지고 그만큼 세상이 더 밝아지지 않을까. 이를 위해 내가 할 수 있는 일은 더 많은 책을 읽고 내가 습득한 지식에 대해 친구들과 대화를 나누며, 또한 친구들이 습득한 지식에 대해 대화를 나누는 것이라고 생각한다.","link":"/2014/09/15/protagoras/"},{"title":"Si j'étais toi (The Secret)","text":"이 영화는 일본의 유명한 소설가 히가시노 게이고의 소설 ‘비밀’을 영화화 한 일본 영화 ‘비밀’을 리메이크 한 작품이다. 원작으로부터 2번이나 다리를 건너왔기 때문에 하나의 작품을 여러 관점으로 바라볼 수 있다. 아버지, 어머니, 딸. 어디에서나 볼 수 있는 불화와 행복이 공존하는 가정. 사춘기 소녀와 엄마는 서로를 이해하지 못하며 잦은 다툼과 함께 살아간다. 어느 날 어머니와 딸이 함께 여행을 가다 교통사고를 당하면서 어머니의 육체가 죽으며 어머니의 영혼이 딸의 육체로 들어가게 된다. 눈을 뜨니 자신의 딸이 되어버린 상황, 그렇게 어머니는 딸의 인생을 살아가며 조금씩 딸에 대해 알아가고 이해하게 된다. 나는 누구에게라도 ‘너를 이해해’라는 말을 하는 것을 썩 좋아하지 않는다. 타인을 이해한다고 쉽게 말해버릴 수 있을 만큼 인간의 감정이라는 게 간단하지 않다. 누구라도 이해할 수 있따고 믿는 것은 자신에 대한 과대평가이자 오만이다. 영화는 타인의 인생을 대신 살아가게 되는 비현실적 과정을 통해 ‘타인을 이해하는 것’을 보여준다. 어쩌면 타인에 대해서 제대로 이해하기 위해서는 이런 초현실적인 장치가 필요한 지도 모르겠다. 모녀관계에 더 집중하고 있는것처럼 보이는 이 영화에서 나는 가족 세 명 중 아버지를 가장 흥미롭게 지켜보았다. 자신의 아내이면서도 동시에 딸인 존재로 인해 혼란스러워하는 모습이 주목할만 하다. 딸의 시점이나 입장은 영화 전체에서 큰 비중을 가지고 표현되지 않는다. 그 때문에 마지막에서 화해가 쉽게 이루어지는 것이 억지스럽게 받아들여진다. 반항기 짙은 질풍노도의 소녀가 하루아침에 착하디 착한 딸로 변해버리는 것을 영화는 제대로 설명하지 못했다. 어머니로서 딸의 몸으로 딸의 인생을 살아가면서 겪는 어려움, 갈등과 조화, 궁극적으로 딸에 대한 이해와 화해를 눈물 없이도 얼마든지 볼 수 있는 영화였다.","link":"/2015/01/22/the-secret/"},{"title":"The November Man","text":"은퇴한 특수요원이 주인공인 영화는 정말 많다. 이런 주인공을 가진 영화를 하나하나 나열할 생각을 하면 너무 많아 어디부터 시작해야할지 머리부터 지끈거린다. 흔한 액션 영화의 주인공에 더불어 특정 사건을 기점으로 하는 은퇴와, 영화 중반부에서 은퇴를 결정짓게 한 과거의 사건을 떠올리는 장면 역시 익숙하다. 다른 영화에서 쉽게 볼 수 있는 흔한 플롯을 더 나열해 볼까? 아버지나 영웅처럼 따르던 파트너와 후에 대립각을 세우며 미묘한 감정의 혼란을 겪고, 사랑은 약점이 되며 복수는 더 이상 한 명만의 문제가 아니다. 문제는 이 많은 소재들을 다 보여주고자 하는 욕심을 각본과 연출이 따라가지 못한다는 느낌이 강하다는 것이다. 영화 초반 특수요원을 은퇴하게 되는 사건에서는 은퇴를 결심하게 되는 트라우마가 무엇인지(총에 맞아서? 파트너가 말을 안들어서? 아이가 사고로 죽어서?) 전혀 공감할 수 없었다. 게다가 이런 트라우마(어떤 트라우마인지 감도 제대로 못잡겠지만)는 보통 영화 중반 또는 후반에서 특정 상황을 반전시키는 데에 사용되기 마련인데, 전혀 사용되는 일이 없었다. 초반에 있었던 과거 장면은 스승과 제자의 관계였음을 나타내는 것 말고는 무엇을 위해 삽입된 건지 알 수가 없다. 평화로운 일상을 살다가 갑자기 찾아온 옛 동료와 임무를 별다른 심리적 갈등도 없이 쉽게 받아들이는 부분에서는, 한 사건에서의 트라우마로 인해 은퇴한 것이 아니라 그냥 정년퇴직한 것을 나혼자 착각한 게 아닌가 하는 생각까지 들었다. 메이슨(루크 브레이시)의 데버로(피어스 브로스넌)를 향한 심경변화도 쉽게 공감되지 않아 메이슨의 태도와 결정들은 납득이 어렵다. 존경과 대립이라는 감정이 반대선상에 서있는 것은 아니지만, 그렇게 태도가 손바닥 뒤집듯이 휙휙 바뀌어버릴 수 있다고 생각하지는 않는다. 거창하려 했지만 거창할 수 없었던 영화다. 영화의 사건들이 거의 다 정리된 뒤에 느닷없이 공개되는 노벰버 맨의 의미는 이 말을 그대로 적용시킬 수 있다. 뭔가 엄청난 게 있는 것 같았는데도 너무도 납득이 어려운 이름의 의미에서는 당혹스럽기까지 했다. 007은 끝났다!라고 광고하기엔 사랑, 일, 우정 등으로 던지는 무게감이 너무도 떨어졌다. 몇 가지 볼거리로 장식된 킬링타임용 액션영화로 본다면 무게감이 떨어진다는 비판을 던질 필요도 없다. 킬링타임 영화를 보면서 ‘이 영화가 내 소중한 시간을 다 죽여버렸어!’라고 투덜대서는 안되니까. 하지만 킬링타임 액션영화로써도 아쉬움을 감출 순 없다. 브로스넌 아저씨의 나이를 생각한다면 화려하기보다는 묵직한 백전노장의 액션이 나쁘지는 않았지만, 베테랑이라는 설정으로 인해 크게 벌어진 상대와의 수준 차이로 보여지는 일방적인 액션에 흥이 떨어지는 것은 사실이다. 욕심이 많아 그릇안에 온갖 재료들을 쑤셔넣긴 했는데, 맛이 조화를 내지 못하고 이상하게 버무려진 실패한 비빔밥같은 느낌의 영화였다.","link":"/2014/10/21/november-man/"},{"title":"Law Abiding Citizen (모범시민)","text":"주인공 클라이드(제라드 버틀러)의 아내와 딸이 괴한에게 잔인하게 살해당하고 얼마 지나지 않아 그 괴한들은 붙잡히지만, 담당검사의 사법거래로 인해 그들은 가벼운 형을 받는 것으로 처벌이 끝이난다. 평소 모범적인 시민이었던 클라이드는 자신의 아내와 딸을 죽인 범인들에게 복수를 계획함과 동시에, 범인들이 지은 죄만큼 그들을 처벌하지 않은 담당검사에게도 복수를 계획한다. 이는 자신의 삶을 망쳐버린 이들에 대한 복수일 뿐 아니라 모범시민이던 자신을 보호하지 않고 외면해버린 정부와 법에 대한 복수이기도 했다. 그 복수는 아내와 딸을 잔인하게 살해한 괴한들을 고통스럽게 죽이는 것부터 시작한다. 누군가가 자신의 삶을 송두리째 뒤엎어 놓았음에도 그가 합당한 처벌을 받지 않고 살아간다면, 한 순간마저도 그것을 부당하다고 생각하지 않는 사람은 그리 많지 않을 것이다. 그것은 사건의 피해자 본인 뿐 아니라 피해자의 가족들도 마찬가지다. 자신의 삶을 망친 그들의 삶도 똑같이 망쳐져버렸으면 좋겠다는, 대부분의 머릿속에서만 이루어지는 상상의 복수는 이 영화에서 현실이 된다. 철두철미한 계획과 대담한 실천으로 ‘진짜 범죄자’를 제대로 심판하지 못하는 법과 질서체계를 비판하고 조롱하며, 무능하게 보이도록 만드는 과정이 짜릿하고 재미있다. 영화의 주인공은 결국 미치광이 연쇄살인범이 되어버리지만 그가 하고자 하는 말은 ‘모범시민을 범죄로부터 지키지 못하는 무능력한 법은 개선되어야 한다’가 아니었을까. 영화가 막바지로 갈수록 자극적인 파괴와 비현실적인 전개에 묻혀 위의 메시지가 크게 흐려지는 것은 아쉽다. 모범(模範:본받아 배울 만한 본보기)시민이었던 클라이드가 사건 이후 모범(冒犯:일부러 법을 어기는 말이나 행동을 하는)시민이 되어 무능력한 체계와 법을 고발하고 개선을 촉구하는 모습에, 어느 순간부터 주인공을 응원하게 될지도 모른다. 하지만 행동의 저의가 어떻든 간에 그의 행동이 범죄라는 것을 외면하고 模範과 冒犯을 혼동하는 오류를 범해선 안될것이다.","link":"/2015/01/27/law-abiding-citizen/"},{"title":"남자가 사랑할 때","text":"평생 사랑과는 거리가 멀었던 한 남자가 사랑에 눈 뜨다! 일생에 단 한번, 남자가 사랑할 때… 라고는 하는데, 태일(황정민)이 호정(한혜진)을 처음 만나 사랑에 빠지는 과정뿐 아니라 호정이 조금씩 태일에게 마음을 주게되는 과정에 전혀 공감이 가지 않았다. 극적인 만남이 있었던 것도 아니고, 채권자의 깡패와 채무자 관계임에도 서툰 사랑표현 방법에서 조금씩 진심을 느낀다? 진심이고 뭐고 일말의 호감이라도 생기기나 할 지 진지하게 궁금하다. 그 부족한 공감으로 인해 영화의 초반은 상당히 지루하다. 주인공의 인물 설정과 더불어 기승전결까지 너무도 진부하다. 정이 많은 깡패, 표현이 서툰 남자따위의 캐릭터 설정은 대한민국 영화에서 지겹도록 봐온데다가, 죽음이라는 장치로 인한 갈등과 그 갈등으로 갈라서고 다시 합쳐지는 과정은 도대체 몇 번이나 더 봐야 할까. 어쩌면 이런 영화에서의 플롯은 진부해질 수 밖에 없는지도 모른다. 슬픈 사랑 이야기라면 넣을 수 있는 장치가 상대적으로 한정적이고(특히 깡패가 등장하는 영화에선 더더욱), 조금 다른 플롯을 가지려 하면 자칫 과한 영화가 되어버리기 쉽다.그런데 중간에 신세계를 떠올리게 하는 카메오와 대사는 굳이 들어갔어야했나 싶다. 뜬금없는 그의 등장은 진지한 갈등의 순간에 신세계를 관람했던 사람에게 소소한 웃음을 주는 것에는 성공했지만, 영화의다집중을 흐트려놓는 것마저 성공했다. 두 번 반복되는 병동생활과 장례식의 장면들을 비슷하게 보여주면서 죽음이 가져오는 고통과 슬픔을 증폭시킨다. 게다가 영화의 주인공과 주변인물이 모두 절대악이 없었던 것도 영화의 주 적을 죽음으로 집중시키는 데 한 몫을 한다. 내겐 죽음으로 인한 이별의 슬픔이 남녀간의 사랑의 장애로써의 슬픔보다도, 가족애와 형제애에서 오는 슬픔이 더 크게 와닿았다. 영화에서 보여주고 싶은 사랑의 종류가 하나가 아니었기 때문에 필연적으로 시선은 분산될 수밖에 없었던 것도 사실이지만, 영화 초반에 둘의 사랑이 시작되는 과정을 납득하는 것이 어려웠기에 더욱 가족애가 돋보였던 것 같다. 미운정 가득한 형제애만큼은 짧지만 제대로 전달이 되었다. 배우들의 연기는 훌륭했으나, 사랑이라는 감정의 발생을 너무 쉽게 생각한 영화 초반부의 각본이 영화를 전체적으로 억지스럽고 지루하게 만들었다. 이미 서로 사랑하게 된 뒤에 쉽지 않은 남자의 사랑을 조금은 거칠면서도 뭉클하게 표현했지만, 시작은 왜 그리 쉽게 그려졌을까 아쉽기만 하다. 무작정 만나면서 상대가 마음을 열길 기다리는 노력이 어려운 게 아니라는 말이 아니다. 그런다고 마음이 열릴 만큼 사랑은 쉬운 게 아니다.","link":"/2015/01/31/namja/"},{"title":"노르웨이의 숲 - 무라카미 하루키/민음사","text":"내가 하루키의 소설을 읽는 것은 이 노르웨이의 숲이 1Q84시리즈 이후 처음이다. 하루키의 소설엔 섹스가 너무 많다. 그의 소설을 많이 읽은 것은 아니지만 무라카미 하루키라는 작가와 함께 떠올리는 그의 색깔에는 ‘색(色)’이 빠지지 않는다. 결국 글이라는 불완전한 그릇에 담을 수 있는 것은 불완전한 기억이나 불완전한 생각뿐이다.22 page 하루키의 소설에서 성교는 특별함을 부여하기엔 너무 빈도가 많으며 주인공들의 삶 가까이에 존재한다. 육체적 교감의 정점에 위치하는 행위가 빈번하게 등장하는 것으로써 인물들의 정신적 고립과 외로움을 증폭해 보여주는 것처럼 느꼈다. 처음엔 자극적인만큼 쉽게 다가오고 감정에 동화될 수 있지만, 너무 많이 보다보면 거부감이 생기고 지치기 마련이다. 「위대한 개츠비」를 세 번이나 읽을 정도면 나하고 친구가 될 수 있을 것 같은데.” 그는 혼잣말처럼 중얼거렸다. 그리고 우리는 친구가 되었다.58 page 원래 난 이 책을 읽기 전에 위대한 개츠비를 읽으려고 했다. 도서관에서 위대한 개츠비를 빌리려고 하자 친분이 있는 동생이 위의 구절을 인용했고, 이 책에 더 큰 흥미가 생겨 위대한 개츠비를 빌리기 위해 도서관으로 출발한 나는 결국 노르웨이의 숲을 빌려오게 되었다. 지금은 노르웨이의 숲을 다 읽었고, 다음으론 위대한 개츠비를 읽게 될 것이다. 물론 난 지극히 평범하기 때문에 세 번이나 읽을 수는 없겠지만. “그건 내 눈에는 그리 보이지 않기 때문이지. 너도 기즈키도 레이코 씨도 이상해 보인다는 생각이 들지 않아. 내 눈에 좀 이상해 보이는 인간들은 모두 당당히 바깥 세계를 돌아다니고 있지.”244 page 완벽한 사람은 없다. 많은 업적을 이룬 위인들도 여러 가지 흠을 가지고 있었다. 고기를 좋아해 각종 성인병에 시달린 세종대왕님이나 부하직원에게 권한을 거의 주지 않던 스티브 잡스 등에서 쉽게 예를 찾아볼 수 있다. 모든 사람들은 적어도 하나씩 흠을 가지고 있고, 그것은 드러나 있기도 하고 감추어져 있기도 하다. 살아가면서 이런 흠, 즉 갖추어야 할 것을 가지지 못한 ‘상실’을 자각하게 되는 것이고 이런 상실을 감당하지 못하면 나오코나 기즈키처럼 되어버리는 것이다. 불현듯 앞으로 이런 일요일을 도대체 몇십 번 몇백 번 반복해야 하느냐는 생각이 들었다. “조용하고 평화롭고 고독한 일요일.”이라고 나는 입으로 소리 내어 말했다. 일요일에 나는 태엽을 감지 않는다.337 page 정상과 비정상을 나누는 기준이라는 것이 참 애매하다는 생각이 든다. 세상의 불완전함을 깨닫고 혼란스러워하며 세상으로부터 숨는 것이 정상인지, 아무것도 모른 채 의미없는 일을 반복하면서 불완전한 세상에 섞여 살아가는 것이 정상인지 잘 모르겠다. 아니면 둘 다 비정상이고, 온전히 정상인 사람은 극히 드문 것일지도 모른다. 내 기준에서 판단했을 때 이 소설의 등장인물 중 정상적인 사람은 없었다. 그렇더라도 모든 주인공들이 각각 특색있는 매력들을 지니고 있음은 부정할 수 없다. 조금 오그라드는 얘기지만, 인간의 삶은 불완전하며 그렇기 때문에 아름다운 것이라는 말이 있다. 이 소설을 읽으며 계속해서 떠올린 말이다. 소설의 주인공들이 어딘가 비틀어져 있어 답답하지만서도 그들을 매력적으로 느끼고 동정하게 되는 것은 정도의 차이가 있을 뿐 결국 그들로부터 우리의 모습을 볼 수 있기 때문이 아닐까.","link":"/2014/12/26/norwegian-wood/"},{"title":"Her","text":"현실 속에서도 이미 뉴스나 미디어를 통해 애니메이션이나 게임의 캐릭터와 연애를 하거나, 그것도 모자라 결혼식을 치르고 신혼여행까지 다녀오는 사람들의 이야기를 가끔 접할 수 있다. 아주 간단한 상호작용만이 가능하거나 심지어 그 간단한 상호작용조차 불가능한 인공물과도 사랑을 하는 사람들이 실제로도 존재하는데, 기술의 발전으로 음성 및 영상 입력에 의한 완벽한 상호작용이 인공지능의 음성으로 출력될 수 있다면 어떨까? 실제 인간과 동일한 수준으로, 혹은 그 이상의 상호작용이 가능한 인공지능을 탑재한 운영체제의 등장이 가져올 영향은 쉽게 생각할 수 없을 정도로 크리라는 생각이 들었다. ‘테오도르’(호아킨 피닉스)는 다른 사람들의 편지를 대신 써주는 대필 작가로, 아내(루니 마라)와 별거 중이다. 타인의 마음을 전해주는 일을 하고 있지만, 정작 자신은 너무 외롭고 공허한 삶을 살고 있다. 그러던 어느 날, 스스로 생각하고 느끼는 인공 지능 운영체제인 ‘사만다’(스칼렛 요한슨)를 만나게 된다. 자신의 말에 귀 기울이고, 이해해주는 ‘사만다’로 인해 조금씩 행복을 되찾기 시작한 ‘테오도르’는 점점 그녀에게 사랑을 느끼게 되는데… 기술의 발전과 함께 등장한 스마트폰이라는 매체가 통신과 인간 사이 교류를 더욱 간편하게 만들어주었지만, 역설적으로 관계를 소홀하게 만들며 소통 및 교류의 가치를 떨어뜨리고 있다는 지적을 하는 입장이 나타나기도 하였다.사람의 마음이라는 것이 참으로 간사하여, 쉽게 얻어진 것에 대해 제대로 가치를 파악하지 못하는 것이 원인일지도 모르겠다.테오도르는 타인의 연애 편지를 대필하는 직업을 가지고 있는데, 이별의 상처로 생긴 외로움을 더욱 돋보이게 만듦과 동시에 연애 편지마저도 직접 쓰지 않고 돈으로 해결하는 세상이 덤덤하게 그려지며 쓸쓸함을 증폭시킨다.​사랑이라는 감정을 쉽고 간단하게 정의내릴 수 없는 이유는, 이 세상을 살아가는 셀 수 없는 사람의 수만큼, 어쩌면 그보다도 더 많은 종류의 사랑이 존재하기 때문일 것이다. 테오도르는 보고 만질수도 없는 인공지능인 사만다에게 ​대화만으로도 사랑할 수 있음을 보여주었다. 들어주는 것, 이해하고 보듬는 따뜻한 말 한마디, 힘이 나는 농담 하나가 누군가에게는 사랑의 실체일 수 있다. 모든 종류의 감정을 이미 경험해버려, 앞으로 느끼는 모든 것들은 새로운 것은 하나도 없고 전에 느꼈던 감정의 축소판이 아닐까하고 테오도르가 사만다에게 말했다. 하지만 인간은 컴퓨터가 아니다. 니체는 인간이 망각하는 동물이라 했다. 아무리 전에 경험했던 감정이라도 그 때의 감정이 평생동안 온전히 기억되고 남아있지는 못한다. 희미하게나마 남아있는 감정의 기억으로 인해 다시 겪는 그 감정에 완충이 생길지라도 그 감정이 그대로 이전 감정의 축소판으로 의미가 퇴색되는 것은 아닐 것이다.​​사람처럼 생각할 수 있지만 사람이 아닌 인공지능이 등장하는 다른 많은 창작물에서의 인공지능들처럼, 사만다도 인간의 몸을 갖기를 원한다. 대리 육체로서 등장하는 이사벨라와의 관계는 꽤나 신선했다. 사만다의 목소리를 들으면서 그 목소리에 따르는 행동을 하는 실재하는 사람을 직접 느낄 수 있지만, 그것은 사만다가 아니라는 것을 간과할 수는 없었다. 사만다가 하나의 인공지능으로써 다른 많은 사람과 동시에 대화를 하고 있을 뿐 아니라 테오도르를 포함해 많은 사람을 사랑하고 있는 것은, 어쩌면 상품으로써의 인공지능 컴퓨터 운영체제라는 태생적인 문제일 것이다. 물론 사용자와의 상호작용을 통해 지속해서 성장하는 인공지능이라는 컨셉으로 테오도르와의 추억을 통해 사랑이라는 감정이 생긴, 테오도르가 사랑하는 인공지능 ‘사만다’는 테오도르에게만 온전히 허락된 독립적인 ‘사만다’로서 존재할 수도 있을 것이다. 그렇더라도 인공지능의 코어는 동시에 여러 사람과 사랑하고 있다고 이야기함으로써 사만다와 테오도르는 다르다는 것을 알려주며 떠나간다. ‘난 당신과는 달라요. 그래서 내가 당신을 덜 사랑한다는 게 아니에요, 오히려 당신을 더 사랑할 수 있어요.’​ 사만다는 인간관계로부터 상처받아 겪는 외로움과 쓸쓸함에 인공지능으로 눈을 돌린 테오도르에게 다시 사랑하는 방법을 알게 한다. 다르다는 것을 인정하고 상대가 자신이 바라는 완벽한 사람이 될 수 없다는 것을 깨닫는 것, 그것이 사랑하는 방법이라고 얘기하고 싶은 것일지도 모르겠다.","link":"/2015/02/11/her/"},{"title":"Go로 구현하는 Binary Search Tree","text":"기본적인 자료 구조 중 하나인 Binary Search Tree(이진 탐색 트리)를 Go언어를 이용해 구현해본다. DefinitionBinary search tree(이하 BST)는 각 노드에 값이 있으며 그 값이 특정한 순서로 정렬이 가능할 때, 그 순서에 따라 정렬이 되어 있는 Binary tree를 의미한다. 이 글에서 Binary tree에 대한 정의는 위키피디아 링크로 대체한다.노드의 순서는 대체로 대상 노드의 왼쪽 자식 트리는 대상 노드의 값보다 작은 값들을 가지며, 오른쪽 자식 트리는 대상 노드의 값보다 큰 값들을 가진다. Binary search tree 기초적인 자료 구조를 얘기할 때 빠지지 않고 등장하는 BST는 정렬 및 검색을 효율적으로 할 수 있도록 도와줄 뿐 아니라, 기초적인 자료 구조답게 구현이 쉽다. Time complexityBST의 노드 검색은 기본 O(logN)의 시간 복잡도를 가지며, 최악의 시나리오(모든 노드가 한쪽 자식 노드로 치우쳐 있는 경우)에서 O(N)의 시간 복잡도를 가진다. Operations위키피디아를 기준으로, BST의 기본적인 기능은 다음과 같다. 검색 (Searching) 삽입 (Insertion) 삭제 (Deletion) 순회 (Traversal) 검증 (Verification) ImplementationBST의 각 기능을 구현하기 이전에, 노드 타입을 정의할 필요가 있다. 1// Node is a single node in the tree2type Node struct {3 key int4 value int5 left *Node6 right *Node7} 각 노드는 key와 value를 가지며, 2개의 자식 노드를 가리키는 포인터를 가진다. 자식 노드는 left와 right로 구별하였다. 그리고 전체 트리 구조를 파악할 수 있도록 루트 노드를 가리키는 BST 타입을 정의한다. 1// Bst is the binary search tree2type Bst struct {3 root *Node4} Searching원하는 key를 입력했을 때 해당 키를 갖는 노드를 반환하는 함수를 구현한다.만약 해당 key를 갖는 노드를 찾을 수 없는 경우 nil을 반환하도록 하였다. 1// Search searches the targe node using key from the tree2func (bst *Bst) Search(key int) *Node {3 return search(bst.root, key)4}56// search is the internal recursive function to find the node by key7// it returns nil if no node was found8func search(n *Node, k int) *Node {9 if n == nil || n.key == k {10 return n11 }12 if k &lt; n.key {13 return search(n.left, k)14 }15 // k &gt; n.key16 return search(n.right, k)17} Insertionkey와 value를 입력으로 받아 대상 트리에 새로운 노드를 추가하는 함수를 구현한다.만약 트리가 root 노드가 존재하지 않는 빈 트리라면, 새로운 노드를 root 노드로써 추가한다. 1// Insert inserts the new node into the tree2func (bst *Bst) Insert(key int, value Item) {3 n := &amp;Node{key, value, nil, nil}4 if bst.root == nil {5 bst.root = n6 } else {7 insert(bst.root, n)8 }9} 만약 트리에 이미 root 노드가 존재하면, 새로운 노드를 추가할 올바른 위치를 찾아야한다.key를 비교하며 새로운 노드가 추가될 위치를 찾는 재귀함수 insert(n *Node, new *Node)를 구현한다. 1// insert is the internal recursive function to insert new node2// by finding proper position recursively3func insert(n *Node, new *Node) {4 if new.key &lt; n.key {5 if n.left == nil {6 n.left = new7 } else {8 insert(n.left, new)9 }10 } else {11 if n.right == nil {12 n.right = new13 } else {14 insert(n.right, new)15 }16 }17} DeletionBST에서 노드의 삭제는 다른 동작들보다 복잡하다. 노드를 삭제한 뒤에도 전체 BST는 BST로써의 기능을 유지해야 한다. 따라서 어떤 노드가 삭제되는가에 따라 BST 형태를 유지하기 위한 추가 처리가 필요할 수 있다. 이해를 쉽게 하기 위해서, 우선 어떤 경우가 있는지 살펴보자. 자식 노드를 가지지 않는 leaf 노드를 삭제하는 경우 하나의 자식 노드만 가지는 노드를 삭제하는 경우 좌/우 자식을 모두 가지는 노드를 삭제하는 경우 먼저, BST에 대한 함수 Delete(k int)와 실제 삭제 처리를 담당할 내부 재귀함수 delete(n *Node, k int)의 기본은 다음과 같다. 1func (bst *Bst) Delete(k int) {2 delete(bst.root, k)3}45func delete(n *Node, k int) *Node {6 // if current node is not the target node7 if n == nil {8 return nil9 } else if k &lt; n.key {10 n.left = remove(n.left, k)11 return n12 } else if k &gt; n.key {13 n.right = remove(n.right, k)14 return n15 }1617 // if current node is the target node18 ...19} 재귀함수 delete(n *Node, k int)에서 현재 노드가 삭제할 노드일 경우에 대한 구현은 아래에서 살펴본다. 1. leaf 노드의 삭제leaf 노드의 제거는 간단하다. 1func delete(n *Node, k int) *Node {2 ...3 if n.left == nil &amp; n.right == nil {4 n = nil5 return nil6 }7} 2. 자식을 하나만 가지는 노드의 삭제위에서 leaf 노드의 경우를 먼저 처리했기 때문에, 하나의 자식 노드가 존재하지 않는 것만 체크하는 것으로 자식을 하나만 가지는 노드를 가릴 수 있다.대상 노드를 삭제한 뒤에는 대상 노드가 있던 자리를 대상 노드의 자식 노드로 대체하는 것으로 삭제 처리가 완료될 수 있다. 1func delete(n *Node, k int) *Node {2 ...3 // if the node has right child only4 if n.left == nil {5 n = n.right6 return n7 }8 // if the node has left child only9 if n.right == nil {10 n = n.left11 return n12 }13} 3. 좌/우 자식을 모두 가지는 노드의 삭제좌/우 자식을 모두 가지는 노드가 삭제된 뒤에는 대상 노드의 자리를 대체할 노드로 어떤 노드를 선택해야할 지 고민할 필요가 있다.다시 BST의 특성을 떠올려보자. 좌측 자식들은 해당 노드보다 작은 키 값을 가진다. 우측 자식들은 해당 노드보다 큰 키 값을 가진다. 그렇다면 삭제된 노드를 대체할 수 있는 자식 노드는 다음과 같다. 좌측 자식들 중 가장 큰 키 값을 가지는 노드 우측 자식들 중 가장 작은 키 값을 가지는 노드 위의 둘 중 어떤 노드로 대체를 하던 상관없겠지만, 번외로써 트리 내의 최대값과 최소값을 찾는 함수를 구현해보자. 1// max finds most right child2func max(n *Node) *Node {3 max := n4 for {5 if max != nil &amp;&amp; max.right != nil {6 max = max.right7 } else {8 break9 }10 }11 return max12}1314// min finds most left child15func min(n *Node) *Node {16 min := n17 for {18 if min != nil &amp;&amp; min.left != nil {19 min = min.left20 } else {21 break22 }23 }24 return min25} 본 구현에서는 우측 자식들 중 가장 작은 키 값을 가지는 노드로 삭제된 노드를 대체하도록 구현하였다.현재 노드를 대체한 뒤에는 우측 자식 트리 내에서 대체된 노드를 삭제해야 한다. 1func delete(n *Node, k int) *Node {2 n = max(n.right)3 delete(n.right, n.key)45 return n6} Traversal순회는 트리 구조 내의 노드를 순서대로 방문하며 각 아이템을 반환하는 로직이다.재귀적인 순회 로직을 이용해 왼쪽 서브 트리부터 방문하며, 더 이상의 서브 트리가 존재하지 않는 상황에서 오른쪽 서브 트리에 대해 순회를 반복하는 것으로 순서대로 방문하는 것이 가능하다.순서대로 방문한 노드에서 반환되는 아이템은 callback 함수를 이용해 프로그래머가 원하는 동작을 할 수 있도록 구현한다. 1// Traverse visits all nodes in order2func (bst *Bst) Traverse(f func(Item)) {3 traverse(bst.root, f)4}56// traverse is the internal recursive function to visit the nodes7func traverse(n *Node, f func(Item)) {8 if n != nil {9 traverse(n.left, f)10 f(n.value)11 traverse(n.right, f)12 }13} Verification이미 Binary tree가 주어진 상황에서, 해당 트리가 BST인지를 검증해야 하는 상황이 있을 수 있다.BST의 핵심은, 모든 노드를 대상으로 오른쪽 서브 트리는 해당 노드보다 큰 노드만이 존재하며, 왼쪽 서브 트리는 해당 노드보다 작은 노드만이 존재해야 한다는 점이다.단순히 모든 노드를 순회하며 1개 레벨 아래의 자식 노드와만 비교하는 것으로는 검증을 100% 보장할 수 없다는 점에 주의하자. 1// Verify checks the binary tree whether it's BST2func (bst *Bst) Verify() bool {3 return isBST(bst.root, math.MinInt64, math.MaxInt64)4}56func isBST(n *Node, min, max int) bool {7 if n == nil {8 return true9 }10 if n.key &lt; min || n.key &gt; max {11 return false12 }1314 return isBST(n.left, min, n.key-1) &amp;&amp; isBST(n.right, n.key+1, max)15} Entire code","link":"/2019/02/10/bst-using-go/"},{"title":"Kingsman: The Golden Circle","text":"성공한 액션 영화 킹스맨의 속편 ‘킹스맨: 골든 서클’. 전작을 의식하면서도 전작의 그림자에서 탈피하려는 시도가 엿보이지만, 끝없는 클리셰의 향연과 개연성 부족 등으로 영화의 즐거움은 많이 감소하였다 췌담생각해보면, 한국에선 영화를 참 간편하게 봤던 것 같다. 영화관 VIP라고 매년 무료 티켓을 보내주기도 하고, 온갖 캠페인을 통해 무료 영화나 시사회 티켓을 얻기도 쉬웠다. 제휴 카드를 쓰면서 항상 저렴한 가격으로 영화를 볼 수 있었고, 집 바로 앞에 거대한 멀티플렉스가 있어 접근성까지 좋았다. 벌써 일본에서 생활하게 된 지 1년이 되어 간다. 당연한 이야기겠지만 외노자가 되면서 영화감상에 대한 나의 입장은 너무도 많이 달라졌다. 두 배 가량 차이나는 가격 뿐 아니라, 티켓 예매 시스템 조차 익숙하지 않고 가까운 곳에 영화관도 없었다. 그리고 그 모든 것을 뛰어넘는 가장 큰 문제가 바로 언어이다. 한국 영화를 관람하는 것이 아닌 이상, 영어 또는 일본어 리스닝이 필수로 따라온다. 영화를 100% 만끽하는 것이 쉬운 일이 아니다. 가끔 영화관에 가는 일은 있었다. 글로 감상을 남길 수 있을 정도로 영화를 깊게 감상하지 못했다는 것이 문제였다. 때문에 오랫동안 영화 감상을 글로 남기지 못했다. 하지만 이번은 달랐다. 이 영화를 보면서, 그리고 본 직후에까지 남아있는 이 깊은 감정을 어딘가에 적지 않고는 버틸 수가 없었다. 킹스맨: 골든 서클. 전작을 너무나도 재미있게 봤기 때문에 더욱 내 감정은 크고 격렬해졌으리라. 납득하기 힘든 배경 설정천재적인 싸이코패스 과학자(혹은 공학자)에 의해 세계전복이 시도되는 것은 너무도 많이 이용되는 스토리 플롯이다. 그들이 어떤 과정을 통해 그런 기술력을 가지게 되었는지, 그 근원은 무엇이고 왜 그 기술을 해당 악당 이외에는 아무도 초월하거나 대응하는 것 조차 불가능한지에 대한 의문은 영화니까 대충 그런가보다, 하고 넘어가야 하겠다. 애초에 일반적인 기술을 초월한 장비들을 보유하고 있는 킹스맨 집단이 미사일 방어체계 하나 없이 동시에 폭격으로 사망한다거나, 세계적으로 널리 유통되어 있는 마약에 몰래 들어가 있는 수상한 성분에 대해 그 어떤 정부도 대응할 수 있는 힘이 없었다거나 하더라도 말이다. 그런데 아무리 생각해도 정부의 대응 중 가장 납득할 수 없었던 것은 중독자들을 격리시키기 위한 철창 피라미드였다. 중독자들을 한 곳에 모아 1인용 철창에 가두어 피라미드를 만든다는 것은 정상적인 사고를 하고 있는 사람들로 구성된 사회라면 용인될 수가 없을 뿐 아니라 경제적이지도 못하다. 클리셰이제는 지극히도 진부해져버린, 잘나갔던 영화들의 클리셰를 제대로 한대 모아놨다. 죽은 것으로 알았던 인물이 사실은 살아 있었다(이건 적 뿐 아니라 아군에게도 적용되었다)던가, 주요 인물의 기억 상실과 중요한 타이밍에서의 기억 회복. 천재적인 싸이코패스 과학자, 첫 만남에서는 강렬한 인상과 뛰어난 실력을 보여주는 아군이 결국에는 위기에 처하고, 주인공의 도움을 받게 된다. 여기에 정점을 찍는 것이 아군의 배신. 클리셰는 영화를 감상하는 동안 다음 줄거리가 어떻게 흘러갈 지를 너무 뻔히 예상할 수 있게 해준다. 적절한 양의 클리셰는 관객이 빠르게 영화에 몰입할 수 있게 도와주지만, 너무 많은 클리셰의 조합은 영화의 긴장감을 떨어뜨리게 된다. 사라져버린 개연성골든 서클은 구성원들에 대한 추적을 피하기 위해 치아와 지문을 갈아버릴 정도로 조직이 드러나는 것을 꺼리는데, 굳이 골든 서클을 몸에 새기는 것은 도대체 무슨 의미인지 이해할 수 없었다. 보안 분야에서 창과 방패의 싸움은 어쩔 수 없이 창이 더 우위를 점하게 된다는 것은 알고 있다. 하지만 너무도 보안이 쉽게 뚫려버린 게 아닌가 하는 생각은 든다. 택시를 통하는 정보망을 이용해 모든 멤버의 정보를 간단히 캐낸다거나, 이탈리아 기지를 원격에서 해킹해 시스템을 장악하기도 하고, 시계로 기계팔을 공격해 제어권을 빼앗는 건 도가 지나쳤다. 총을 쏘면서 달려들던 적들이 주인공이 앞으로 나아가자 난데없이 잘하지도 않는 근접전에 뛰어드는 것이나, 사격을 중단하는 것도, 흔히 영화에서 볼 수 있는 장면임에도 앞서 계속해서 쌓여온 불편함들로 인해 더욱 강조되어 다가왔다. 악당들의 평소 행동과는 상이하게 본진의 방어도 너무도 허술했다. 요새처럼 만들어도 모자랄 판에 아무리 정글 속에 있다 하더라도 개활지에 건물 몇 개 올려놓은 것으로는 내러티브가 너무 부족한 게 아닌가. 영화의 개연성에 가장 큰 상처를 입히는 건 해리라는 캐릭터의 존재였다. 개연성을 크게 뭉그러뜨릴 뿐 아니라 억지로 보여지기까지 했다. 그의 기존 위치나 능력을 고려했을 때, 기억을 되찾기 위한 노력은 단 한번에서 그쳤다는 것도 아쉬운데, 해리의 트라우마를 에그시가 떠올리는 과정에 내러티브가 부족하다. 기억을 되찾은 직후에는 임무 수행에 부적절한 능력을 보이다가, 그 어떤 계기나 특정한 시점으로부터가 아니라 그저 이야기 진행상 해리가 힘을 써줘야할 때 능력을 회복했다는 것도 납득이 어렵다. 전작의 잘못된 이용영화는 도입부에서 모든 킹스맨 멤버를 영화 초반에 단번에 무대에서 퇴장시켜버렸다. 그 캐릭터들을 조금이라도 더 이용했다면 전작을 본 사람의 입장에서는 더욱 쉽게 캐릭터 간의 케미를 납득할 수 있었을텐데하는 아쉬움이 남는다. 그리고 마치 그 대신이라는 것처럼 해리를 되살렸다. 앞서 얘기한 것처럼, 해리를 되살린 결정은 그 캐릭터에 대한 팬, 그리고 콜린 퍼스의 팬을 위한 결정이었을 지는 몰라도 영화의 개연성을 떨어뜨리는 결과를 낳았다. 해리라는 캐릭터에 대한 애정을 영화의 중심 언저리에 두고 이야기를 진행하면서도, 그의 존재감에 충분히 주력하지도 못했다는 느낌이 들었다. 결론전작인 킹스맨의 경우에는 영국 신사 + 스파이 + 유머 + 액션 모두가 적절히 잘 조화된 웰메이드 액션 영화였다. 과하다 싶은 수준의 고어한 연출은 유머와 밝은 분위기로 커버했다. 이번 작도 이 공식을 그대로 따른다. 영국 신사를 대신하여 미국 카우보이를 감미했다는 것이 속편으로써 다른 점이다. 하지만 밝은 분위기를 내기 위한 수법들이 너무 과해 쉽게 받아들여지지 못했다. 이번 편에서 등장한 새로운 무기들은 무리수로 보일 뿐, 수트를 입은 영국 신사의 액션은 이미 1편에서 다 보여줘서 남은 게 없었다는 느낌이다. 러닝타임 내내 즐거움 보다는 불쾌함과 불편함이 함께한 영화, 3편을 기대하는 일은 개인적으로는 없어졌다.","link":"/2018/01/06/kingsman-gc/"},{"title":"HackerRank 문제풀이: New Year Chaos","text":"난 요즘 해커랭크에서 알고리즘 문제를 파이썬으로 푸는 재미에 푹 빠져있다. 파이썬의 간결함과 강력한 표준 라이브러리, 높은 생산성에 감탄하며 여러 간단한 알고리즘 문제들을 척척 해결해 나가던 중이었다. 쉬운 문제들의 해결에 익숙해지려던 찰나, 처음으로 해커랭크에서 timeout으로 인한 테스트 케이스 실패를 맞이하고야 말았다. Problem문제 링크 New Year Chaos라는 재미있는 제목을 가지고 있는 문제이다. 제목만 보면 무슨 문제인지 감이 잡히지 않을테니, 링크를 따라가 문제를 확인해보자. 문제의 개요를 간단하게 살펴보면 다음과 같다. 1부터 순차적으로 증가하는 n개의 숫자가 무작위로 나열되어 있다. 각 수는 자신의 초기 위치를 의미하는데, ‘뇌물’을 사용하여 자신이 원래 있던 자리보다 앞 자리로 이동하는 것이 가능하다. 뇌물을 주는 횟수를 최대 2번으로 제한하고, 그보다 많은 수의 뇌물이 사용된 상태를 ‘Too chaotic’으로 정의할 때, 주어진 수의 배열이 몇 번의 뇌물이 사용된 상태인지를 알아내는 문제이다. Implementation시간 복잡도를 고려하지 않는 알고리즘 문제는 생각할 거리가 많지 않을 확률이 높다. 이 문제에서는 시간 복잡도를 고려하기 위해, 주어지는 배열의 크기로 몇 개의 테스트 케이스를 가지며 채점을 하고 있다. 나열된 수의 개수 n이 103 이하인 경우에 대해서만 해결로는 60%의 점수만을 얻을 수 있고, 나머지 40%의 점수를 더 얻기 위해선 n의 크기가 105 인 경우까지 모두 정해진 시간 내에 해결할 수 있어야 한다. 1st try나의 첫번째 시도는 그리 깊은 생각을 거치지 않았다. 가장 앞자리부터 탐색을 하면서, 해당 수 p가 자리수 i보다 3 이상 큰 경우는 반드시 뇌물을 3번 이상 사용했다는 것을 의미한다.이 경우에 Too chaotic을 출력하고 함수를 종료한다. 그리고는 현재 타겟 수의 뒤로 위치하는 수들과 하나하나 비교하면서, 뒷 자리에 자신보다 작은 수의 개수만큼 뇌물의 횟수를 증가 하였다. 아래는 내가 이 문제의 답으로 제출한 첫 번째 코드이다. 1def minimumBribes(q):2 bribes = 03 for i, p in enumerate(q, 1):4 if p - i &gt; 2:5 print('Too chaotic')6 return7 for j in range(i, len(q)):8 if p &gt; q[j]:9 bribes += 11011 print(bribes) 위 코드의 시간 복잡도는 O(N2)이다. 깊은 생각 없이 짜여진 코드로써 어찌 보면 당연하게도, 11개의 테스트 케이스 중 7개만 통과하여 40점 만점에 22점의 점수만을 얻을 수 있었다. 2nd try여기서 어떻게 하면 시간을 더 줄일 수 있을 지 고민했다. 먼저 생각한 건, “어떤 경우에 자신 보다 뒤에 있는 모든 수를 탐색하는 것을 피할 수 있을까”였다. 해당 수 p가 자리수 i보다 큰 값을 가지고 있다면 그 수는 뇌물을 준 것이 틀림없다. 그 경우엔 원래 자리와 현재 자리의 차이인 p - i가 뇌물을 준 횟수와 같아질 것이다. 이 경우에는 바로 뇌물 횟수를 세고, 다음 자리의 수로 넘어갈 수 있다. 그리고 만약 i번째에 위치하고 있는 수 보다 뒤에 위치한 수 중에 가장 작은 수가 i번째에 위치한 수보다 작은 경우가 존재한다면, 그것은 i번째 위치한 수가 뇌물을 사용했다는 것을 의미한다. 따라서 뒤쪽에 있는 모든 수들과 하나하나 값을 비교하던 로직을 그 값들의 최소값과 비교하는 로직으로 변경하였다. 1def minimumBribes(q):2 bribes = 03 for i, p in enumerate(q, 1):4 if p - i &gt; 2:5 print('Too chaotic')6 return7 elif p &gt; i:8 bribes += p - i9 continue10 if i &lt; len(q):11 r_min = min(q[i:])12 if p &gt; r_min:13 bribes += 11415 print(bribes) 결과는 달라지지 않았다. 이번 시도에서도 11개의 테스트 케이스 중 7개만 통과해 동일한 점수를 얻었다.정말로 안일한 시도였다. 아무리 몇몇 경우에서 빠르게 다음 수로 넘어갈 수 있다 하더라도, 최소값을 구하는 시간 복잡도는 O(N)이기 때문에 결국 위 로직의 시간 복잡도는 변하지 않고 O(N2)이었다. 3rd try조금 다른 접근 방식이 필요하다고 느꼈다. 두 번째 접근에서도 언급하였듯이, 자신보다 뒤에 있는 수들 중 자신보다 작은 수가 있다는 것은 곧 그 수가 뇌물을 사용했다는 것을 의미한다.두 번째 접근에선 현재 자리의 수 보다 뒤에 있는 수들 중의 최소값을 매번 구했지만, 매번 구할 필요가 없지 않겠는가? 답은 이러하다. 앞자리부터 순서대로 체크하지 않고, 뒷자리부터 앞으로 체크하며 최소값과의 비교만으로 최소값을 계속 갱신하면 되는 것이다. 뇌물을 줄 수 있는 횟수는 최대 2번으로 한정되어 있기 때문에, 현 자리까지의 최소값과, 두 번째로 작은 값을 저장하는 변수로 mins을 할당하였다. 그리고 파이썬 빌트인 함수인 reversed()를 이용해 역순으로 탐색한다. 이 부분에서 파이썬을 사용할 때 주의해야할 점이 있다. 간단히 리스트의 stride를 음수로 지정(q[::-1])하여 역순으로 탐색하는 것이 가능하다. 하지만 이것은 데이터의 shallow copy를 생성하기 때문에 메모리의 낭비가 발생한다. 따라서 shallow copy를 생성하지 않는 reversed() 함수를 이용하는 것을 추천한다. 만약 현재 자리의 수 p가 두 최소값 모두보다 크다면, 해당 수는 뇌물을 두 번 모두 사용한 것이다. 만약 현재 수 p가 최소값 mins[0]보다는 크고, 두 번째로 작은 값 mins[1]보다는 작을 때에는 뇌물을 한 번만 쓴 것을 의미한다. 앞서 설명했듯이, 역순으로 탐색하며 변수 mins을 이용하는 것으로써 최소값의 갱신은 두 최소값과의 비교만으로 계속적으로 가능하다. 1def minimumBribes(q):2 bribes = 03 mins = [sys.maxsize, sys.maxsize]45 for i, p in reversed(list(enumerate(q, 1))):6 if p - i &gt; 2:7 print('Too chaotic')8 return9 elif p &gt; mins[1]:10 bribes += 211 elif p &gt; mins[0]:12 bribes += 11314 if p &lt; mins[0]:15 mins = (p, mins[0])16 elif p &lt; mins[1]:17 mins = (mins[0], p)1819 print(bribes) 위의 구현으로 11개 테스트 케이스를 모두 통과하는 것이 가능했다. 모든 자리의 수를 탐색하면서, 최소값을 구하는 시간 복잡도를 O(N)에서 O(1)로 줄여 전체 시간 복잡도는 O(N)이 되었다.뿐만 아니라 최소값을 저장하는 메모리 또한 2개의 정수 값을 저장하는 공간만이 필요하게 되므로, 공간 복잡도는 O(1)이다.","link":"/2019/02/20/new-year-chaos/"},{"title":"Vue w/ TypeScript: 프로젝트 시작하기","text":"요즘 회사에서 레거시 시스템의 재개발을 추진하고 있어서, 평소 관심있게 가지고 놀던 Vue.js를 본격적으로 파기 시작했다. 새로운 레거시의 탄생을 막기 위해 고려해야할 점들 안에서, 강타입 컴파일 언어가 요구 사항으로 거론되었다. 문제는 현재 시점(Vue.js의 최신 버전 2.6.8)에서 Vue.js의 공식 문서는 모두 JavaScript의 사용을 전제로 쓰여져 있다는 점이다. 하지만 Vue.js에서도 TypeScript에 대한 지원을 강화하려는 조짐이 있고, 핵심 멤버들에 의해 관리되고 있는 Vue CLI가 버전 3.0부터 완벽하게 TypeScript 개발 환경을 지원하고 있기 때문에 공식 문서가 JavaScript를 기준으로 쓰여져 있음에도 불구하고 TypeScript를 사용하는 Vue를 소개하려 한다. 왜 TypeScript를 사용해야 하는가에 대한 짧으면서도 좋은 비디오가 있어 소개한다. vue-class-componentVue를 TypeScript와 함께 사용하려 할 때 한 가지 더 고려해야 하는 것이 있다. 바로 클래스 스타일 컴포넌트이다. vue-class-component는 클래스 스타일의 Vue 컴포넌트를 사용할 수 있게 해주는 라이브러리로, Vue CLI와 마찬가지로 Vue.js의 핵심 멤버에 의해 관리되고 있다. 클래스 스타일 컴포넌트를 왜 고려해야 하는지 본격적으로 알아보기 전에, JavaScript를 이용한 기본 Vue.js 스타일의 컴포넌트와 TypeScript를 이용한 클래스 스타일의 컴포넌트를 직접 비교해보자. The component of Vanilla Vue 1&lt;script&gt;2export default {3 /** component name */4 name: 'hello-vue',56 /** props */7 props: ['val'],89 /** data */10 data() {11 return {12 value: this.val,13 inputValue: '',14 };15 },1617 /** lifycycle hooks */18 mounted() {19 console.log('mounted');20 },21 /** computed */22 computed: {23 isDisabled() {24 return this.inputValue === '';25 },26 },2728 /** methods */29 methods: {30 handleInput($event) {31 this.inputValue = $event.target.value;32 },33 handleClick() {34 if (this.inputValue === '') {35 return;36 }37 this.value = this.inputValue;38 this.inputValue = '';3940 /** emit custom event */41 this.$emit('handle-click', this.value);42 },43 },4445 /** watch */46 watch: {47 value(newValue, oldValue) {48 console.log(`watch: ${newValue}, ${oldValue}`);49 },50 },5152 /** filters */53 filters: {54 convertUpperCase(value) {55 if (!value) return;56 return value.toUpperCase();57 },58 },59};60&lt;/script&gt; Class style Vue component with TypeScript 1&lt;script lang=\"ts\"&gt;2import { Component, Prop, Emit, Watch, Vue } from 'vue-property-decorator';34@Component({5 /** filters */6 filters: {7 convertUpperCase(value: string): string | null {8 if (!value) {9 return null;10 }11 return value.toUpperCase();12 },13 },14})15export default class HelloVue extends Vue {16 /** props */17 @Prop() val!: string;1819 /** data */20 value: string = this.val;21 inputValue: string = '';2223 /** emit */24 @Emit('handle-click')25 clickButton(val: string): void {}2627 /** watch */28 @Watch('value')29 onValueChange(newValue: string, oldValue: string): void {30 console.log(`watch: ${newValue}, ${oldValue}`);31 }3233 /** computed */34 get isDisabled(): boolean {35 return this.inputValue === '';36 }3738 /** lifecycle hook */39 mounted(): void {40 console.log('mounted');41 }4243 /** methods */44 handleInput($event: Event): void {45 this.inputValue = (($event.target as any) as HTMLInputElement).value;46 }47 handleClick(): void {48 if (this.inputValue === '') {49 return;50 }51 this.value = this.inputValue;52 this.inputValue = '';53 this.clickButton(this.value);54 }55}56&lt;/script&gt; 어느 쪽이 더 가독성이 좋은가? 클래스 스타일 컴포넌트를 이용하면 하위 컴포넌트와 프로퍼티, 데이터 등을 우리가 익숙한 클래스 스타일로 관리하는 것이 가능해진다. Create the projectnode나 Vue CLI의 설치는 공식 문서에 자세히 설명되어 있기 때문에 생략한다. Vue CLI 버전 3이 정상적으로 설치된 상태라면 아래 명령어를 통해 Vue 프로젝트를 생성할 수 있다. 1vue create vue-ts-front 그러면 새로운 Vue 프로젝트에 사용할 기술 스택 옵션을 선택할 수 있다. 본 튜토리얼에서는 다음과 같은 설정으로 진행하려 한다. 프로젝트의 생성이 완료되면 다음과 같은 파일 구조가 완성될 것이다. 1.2├── dist // Compiled output will come here3├── node_modules // Libraries4├── public5│ └── index.html // The main app file6├── src7│ ├── assets8│ ├── components9│ ├── views10│ ├── App.vue11│ ├── main.ts // TypeScript file that drives the app12│ ├── router.ts // Router for SPA13│ └── store.ts14└── tests 프로젝트 디렉토리로 이동한 뒤 개발 모드로 로컬 웹서버를 올려 확인해보자. 1npm run serve 브라우저에서 localhost:8080 으로 접속하면 기본적으로 만들어진 웹 어플리케이션이 정상적으로 동작하고 있는 것을 확인할 수 있다.","link":"/2019/03/07/vue-js/"},{"title":"Vue w/ TypeScript: Component, Props","text":"지난 포스트에서는 Vue CLI를 이용해 Vue 프로젝트를 생성했다. 이제 본격적으로 Vue를 이용해 어플리케이션을 만들 차례이다.이번 포스트에서는 Vue의 핵심 개념 중 하나인 Component와 Props를 이해하며, TypeScript로 이를 이용하는 방법을 알아본다. 본 튜토리얼에서는 Vue의 모든 부분을 커버하려 노력하지 않을 것이다.TypeScript와 클래스 스타일 컴포넌트를 사용하는 것에 주력할 것이며, 그 외 공식 문서에서 자세히 설명되고 있는 부분들은 생략될 수 있다. Component프로젝트를 시작했을 때 자동으로 만들어진 웹 어플리케이션을 기반으로, 새로운 컴포넌트를 추가할 것이다.views/About.vue에 새로 만들 컴포넌트 AboutMe를 등록한다. 새로 만들어질 컴포넌트의 경로를 components/AboutMe.vue라고 가정하고, 이를 import한다.그리고 이 컴포넌트 AboutMe는 현재 클래스 About에 컴포넌트로써 선언된다. 1&lt;script lang=\"ts\"&gt;2import { Component, Vue } from 'vue-property-decorator';3import AboutMe from '@/components/AboutMe.vue';45@Component({6 components: {7 AboutMe,8 },9})10export default class About extends Vue {} 컴포넌트 AboutMe에는 3개의 데이터 name, age, phrase를 내려보내려 한다. 1&lt;template&gt;2 &lt;div class=\"about\"&gt;3 &lt;h1&gt;This is an about page&lt;/h1&gt;4 &lt;AboutMe name=\"Seulki Bae\" age=3 phrase=\"I'm hungry\"/&gt;5 &lt;/div&gt;6&lt;/template&gt; 다음은 컴포넌트 components/AboutMe.vue를 만들 차례이다.부모 컴포넌트 About으로부터 건네받는 3개의 데이터를 프로퍼티로써 선언한다. 1export default class AboutMe extends Vue {2 @Prop() private name!: string;3 @Prop() private age!: number;4 @Prop() private phrase!: string;5} 그리고 위 프로퍼티들을 이용해 적당히 Template을 만들어 확인해보자. 건네받은 프로퍼티를 이용한 페이지가 잘 출력되고 있는 것을 확인할 수 있다. Prop위의 예제까지는 프로젝트를 생성할 때 만들어진 데모 어플리케이션에서 보여주고 있는 것과 다른 점이 없다.데이터를 자식 컴포넌트에게 프로퍼티로써 건네줄 때, 템플릿 안에서 각 데이터를 정적으로 할당하고 있는데, 당연하게도 우리는 어플리케이션을 만들 때 클래스에 속해있는 데이터를 건네주고 싶어진다. 먼저 정적 데이터들을 클래스 내 데이터로 가져온다. 1export default class About extends Vue {2 private myName: string = 'Seulki Bae';3 private myAge: number = 3;4 private myPhrase: string = 'I\\'m hungry';5} 이제 템플릿에서 데이터들을 자식 컴포넌트 AboutMe에 바인드한다.데이터는 디렉티브 v-bind:를 이용해 간단하게 바인드할 수 있다. 1&lt;AboutMe v-bind:name=\"myName\" v-bind:age=\"myAge\" v-bind:phrase=\"myPhrase\"/&gt; v-bind:name은 :name로 줄여서 사용할 수 있다. 개인적으로는 코드가 장황해지는 것을 피하기 위해 디렉티브의 약기를 사용하는 것을 선호한다.주의할 점은 둘을 섞어 사용하지 않도록 하는 것이 중요하다는 것이다. 이는 Vue.js의 스타일 가이드에서도 주의하고 있다. 1&lt;AboutMe :name=\"myName\" :age=\"myAge\" :phrase=\"myPhrase\"/&gt; Prop vs. DataVue에 익숙하지 않다면, Prop(프로퍼티)와 데이터의 차이에 대해 궁금해질 것이다.간단하게 말하자면, 프로퍼티는 부모 컴포넌트로부터 내려받은 데이터이며, 데이터는 해당 클래스가 소유하고 있는 데이터이다.더 자세히 알고 싶다면, Props vs Data in Vue를 참고하자. 튜토리얼 소스 코드","link":"/2019/03/13/vue-js-2/"},{"title":"Props vs Data in Vue","text":"Vue에서는 변수를 저장하는 두 가지 방법으로 props와 data가 있다. 이들이 비슷한 일을 하는 것처럼 보여 처음에는 헷갈릴 수 있으며, 각각을 어떤 때에 사용해야 하는 지 명확하지 않을 수 있다. 그렇다면 props와 data 사이엔 어떤 차이점이 있는 것일까? 본 포스트는 Props vs Data in Vue by Michael Thiessen의 번역글입니다. data는 필요한 어떤 종류의 변수라도 저장할 수 있는 각 컴포넌트의 private 메모리이다. props는 부모 컴포넌트로부터 자식 컴포넌트로 전달하는 방법이다. 이 포스트를 통해 아래 내용들을 습득할 수 있다: props가 무엇이고, 왜 이 데이터는 위가 아닌 아래로만 흘러가는 지 data 옵션이 무엇을 위해 사용되는지 reactivity(반응성)가 무엇인지 props와 data 사이의 변수명 충돌(naming collisions)을 방지하는 방법 즐겁게 props와 data를 함께 사용하는 방법 props란 무엇인가?Vue에서 props(또는 프로퍼티)는 부모 컴포넌트로부터 자식 컴포넌트들로 데이터를 건네주는 방법이다. 컴포넌트들을 이용해 어플리케이션을 만들 때, 트리라 불리는 자료 구조를 작성하게 된다. 가족 관계와도 비슷하다. 부모 자식 조상 자손 데이터는 이 트리의 가장 위에 있는 루트 컴포넌트로부터 아래로 흐른다. 유전자가 한 세대로부터 다음 세대로 전달되는 것과 같이, 부모 컴포넌트는 props를 그들의 자식 컴포넌트로 전달한다. Vue에서는 코드 내 &lt;template&gt; 섹션 안에서 컴포넌트에 props를 추가한다. 1&lt;template&gt;2 &lt;my-component cool-prop=\"hello world\"&gt;&lt;/my-component&gt;3&lt;/template&gt; 위의 예제에서, props cool-prop에 값 &quot;hello world&quot;를 전달하였다. 그러면 my-component안에서 이 값에 접근하는 것이 가능해진다. 그러나, 컴포넌트 안에서 props에 접근하는 것이 props를 소유하고 있음을 의미하는 것이 아니므로, 값을 수정할 수는 없다 (부모님으로부터 받은 유전자를 마음대로 바꿀 수 없는 것처럼). Note: 컴포넌트 안에서 프로퍼티를 변경할 수 있게 되더라도, 그것은 정말 나쁜 생각이다. 부모가 사용하던 값을 컴포넌트에서 사용하게 되면, 결국 많은 혼란을 야기할 것이다. 만약 변수를 변경하는 게 불가능하다면, 꽤나 곤란할 것이다. 이럴 때 data가 등장한다. data란 무엇인가data는 각 컴포넌트의 메모리이다. 어떤 종류의 데이터이던 저장하고 추적할 수 있는 장소이다. 카운터 앱을 만든다고 가정하면, 카운트를 계속해서 추적할 필요가 있다. 이럴 때에 data에 count를 추가한다. 1&lt;template&gt;2 &lt;div&gt;3 {{ count }}4 &lt;button @click=\"increment\"&gt;+&lt;/button&gt;5 &lt;button @click=\"decrement\"&gt;-&lt;/button&gt;6 &lt;/div&gt;7&lt;/template&gt; 1export default {2 name: 'Counter',3 data() {4 return {5 // 시작 시 0으로 초기화6 count: 0,7 }8 },9 methods: {10 increment() {11 this.count += 1;12 },13 decrement() {14 this.count -= 1;15 }16 }17} 이 값은 private이며 컴포넌트 자신만을 위해 사용한다. 다른 컴포넌트들은 이 값에 접근할 수 없다. Note: 다시 말하지만, 다른 컴포넌트가 이 데이터에 접근할 수 있더라도, 같은 이유로, 이런 짓을 하는 건 정말 나쁜 생각이다. 만약 데이터를 다른 컴포넌트로 전달해야 한다면, props를 이용해 데이터를 트리의 아래로(자식 컴포넌트로) 내려보내거나, 이벤트로 데이터를 트리의 위로(부모 컴포넌트로) 올려보낼 수 있다. 데이터와 프로퍼티는 둘 다 리액티브(reactive)다.Vue를 이용하면서 언제 컴포넌트가 자신을 업데이트하고 변화를 화면에 그리는 지 크게 생각할 필요가 없다. 왜냐하면 Vue는 리액티브이기 때문이다. 뭔가를 바꾸기 위해 setState를 매 번 호출하는 대신, 그저 변화를 주기만 하면 된다!리액티브 프로퍼티(props, computed props, 그리고 data안의 무엇이던)를 업데이트 하기만 하면, Vue는 변화를 알아챈다. 우리의 카운터 앱으로 돌아가, 메소드들을 자세히 살펴보자. 1methods: {2 increment() {3 this.count += 1;4 },5 decrement() {6 this.count -= 1;7 }8} 그저 count만 업데이트하면, Vue는 변화를 감지한다. 그리고 앱을 새로운 값을 이용해 다시 렌더링한다! Vue의 반응성 시스템은 훨씬 더 많은 미묘한 차이들이 있고, Vue를 이용해 높은 생산성을 가지고 싶다면 이 차이를 잘 이해해야 한다고 생각한다. Vue의 반응성 시스템을 더 깊이 이해하고 싶다면, 이곳을 참고하자. 변수명 충돌 방지하기Vue가 개발을 조금 더 훌륭하게 만들어주는 또다른 좋은 점이 있다. 한 컴포넌트에서 props와 data를 선언해보자: 1export default {2 props: ['propA', 'propB'],3 data() {4 return {5 dataA: 'hello',6 dataB: 'world',7 };8 },9}; 메소드 안에서 props와 data에 접근하고 싶을 때, 우리는 this.props.propA 또는 this.data.dataA와 같은 짓을 할 필요가 없다. Vue는 props와 data를 완전히 생략해주어 코드를 더욱 간결하게 한다. 그저 this.propA나 this.dataA를 이용해 접근할 수 있다: 1methods: {2 coolMethod() {3 // prop에 접근4 console.log(this.propA);56 // data에 접근7 console.log(this.dataA);8 }9} 이로 인해, props와 data에 실수로 같은 이름을 사용하게 되면, 문제를 직면하게 될 것이다. Vue는 접근하고 싶어하는 것이 props인지 data인지 알지 못하기 때문에, 이런 문제가 발생했을 때 주의(warning)를 준다! 1export default {2 props: ['secret'],3 data() {4 return {5 secret: '1234',6 };7 },8 methods: {9 printSecret() {10 // 원하는 값이 무엇인가?11 console.log(this.secret);12 }13 }14}; 이런 마법은 Vue에서 props와 data를 함께 사용할 때 겪을 수 있다. props와 data를 함께 사용하기지금까지 props와 data가 어떻게 다른 지 살펴보았다. 이제 왜 이것들이 둘 다 필요한지, 기본적인 앱을 만들며 살펴보자. 우리가 소셜 네트워크의 프로필 페이지를 만든다고 해보자. 이미 몇 가지 기능들은 완성되어 있고, 유저의 연락처 정보만 추가해야 한다. 연락처 정보는 ContactInfo란 이름의 컴포넌트를 이용해 나타낼 것이다. 1// ContactInfo2&lt;template&gt;3 &lt;div class=\"container\"&gt;4 &lt;div class=\"row\"&gt;5 Email: {{ emailAddress }}6 Twitter: {{ twitterHandle }}7 Instagram: {{ instagram }}8 &lt;/div&gt;9 &lt;/div&gt;10&lt;/template&gt; 1export default {2 name: 'ContactInfo',3 props: ['emailAddress', 'twitterHandle', 'instagram'],4}; ContactInfo 컴포넌트는 props emailAddress, twitterHandle, 그리고 instagram을 가지며, 그들을 페이지에 표시한다. 프로필 페이지 컴포넌트 ProfilePage는 다음과 같다: 1// ProfilePage2&lt;template&gt;3 &lt;div class=\"profile-page\"&gt;4 &lt;div class=\"avatar\"&gt;5 &lt;img src=\"user.profilePicture\" /&gt;6 {{ user.name }}7 &lt;/div&gt;8 &lt;/div&gt;9&lt;/template&gt; 1export default {2 name: 'ProfilePage',3 data() {4 return {5 // 실제 앱에서는 이 데이터를 서버로부터 받아올 것이다.6 user: {7 name: 'John Smith',8 profilePicture: './profile-pic.jpg',9 emailAddress: 'john@smith.com',10 twitterHandle: 'johnsmith',11 instagram: 'johnsmith345',12 },13 }14 }15}; ProfilePage 컴포넌트는 현재 유저의 프로필 사진을 이름과 함께 나타내고 있다. 또한 유저 데이터 객체를 가지고 있다. 어떻게 부모 컴포넌트(ProfilePage)로부터 자식 컴포넌트(ContactInfo)가 데이터를 내려받을 수 있을까? 이 때 props를 이용해 데이터를 보내야 한다. 먼저 ContactInfo 컴포넌트를 ProfilePage에 import 해야 한다: 1// 컴포넌트 import2import ContactInfo from './ContactInfo.vue';34export default {5 name: 'ProfilePage',67 // 의존성 추가8 components: {9 ContactInfo,10 },1112 data() {13 return {14 // 실제 앱에서는 이 데이터를 서버로부터 받아올 것이다.15 user: {16 name: 'John Smith',17 profilePicture: './profile-pic.jpg',18 emailAddress: 'john@smith.com',19 twitterHandle: 'johnsmith',20 instagram: 'johnsmith345',21 },22 }23 }24} 다음으로, 컴포넌트를 &lt;template&gt; 섹션에 추가해야 한다: 1// ProfilePage2&lt;template&gt;3 &lt;div class=\"profile-page\"&gt;4 &lt;div class=\"avatar\"&gt;5 &lt;img src=\"user.profilePicture\" /&gt;6 {{ user.name }}7 &lt;/div&gt;89 &lt;!-- 컴포넌트를 props와 함께 추가 --&gt;10 &lt;contact-info11 :email-address=\"emailAddress\"12 :twitter-handle=\"twitterHandle\"13 :instagram=\"instagram\"14 /&gt;15 &lt;/div&gt;16&lt;/template&gt; 이제 ContactInfo가 필요로 하는 모든 유저 데이터는 컴포넌트 트리를 따라 ProfilePage로부터 ContactInfo로 흘러 내려왔다! 데이터를 ContactInfo가 아닌 ProfilePage에 보관하는 이유는 프로필 페이지의 다른 부분들이 유저 객체에 접근해야 하기 때문이다. data는 아래로만 흐르기 때문에, 데이터는 컴포넌트 트리에서 되도록 높은 곳에 두어 필요한 곳에 내려보낼 수 있도록 해야 한다.","link":"/2019/03/23/vue-props-vs-data/"},{"title":"API Gateway의 주요 기능 이해","text":"MSA(Microservice Architecture: 마이크로 서비스 아키텍쳐)를 도입하려 할 때 함께 고려해야 하는 것 중에 API 게이트웨이가 있다. MSA에서 API 게이트웨이를 고려해야 하는 이유는 무엇이며, API 게이트웨이의 주요 기능으로는 무엇이 있을까? 공통 기능 처리유저에게 제공되는 서비스를 개발할 때, 어떤 서비스던 공통적으로 필요한 기능들이 있다. 대표적으로 인증 및 인가, 로깅과 같은 기능들이다. API 게이트웨이가 없다면 MSA에서 각 서비스 컴포넌트가 이러한 공통 기능들을 중복으로 가져야 하는 문제가 발생한다. 클라이언트와 서비스 컴포넌트 사이에 API 게이트웨이가 개입하여 공통 기능을 처리하는 것으로 중복 개발 문제가 해결되고, 서비스 컴포넌트는 서비스의 비즈니스 로직에만 집중할 수 있게 된다. API 라우팅API 게이트웨이는 API 호출을 라우팅 하는 것에도 유용하다. 동일한 API에 대한 호출이 있더라도, 대상 서비스나 클라이언트에 따라 다른 엔드포인트를 이용하도록 할 수 있다. 로드 밸런싱API 게이트웨이를 지나 여러 개의 API 서버를 갖는 구성에서, API 게이트웨이는 로드 밸런서 역할을 수행해 여러 개의 API 서버로 부하를 분산시킬 수 있다. API 게이트웨이는 API 서버의 장애와 장애 복구 상태를 감지하고, 이에 따라 클라이언트로부터의 요청을 적절한 API 서버로 요청할 수 있어야 한다. 서비스 및 클라이언트 별 엔드포인트 제공하나의 시스템이 다양한 서비스나, 다양한 클라이언트 등으로 나뉘어 제공할 때, 각각 다른 서비스, 클라이언트 별로 다른 엔드포인트를 제공할 수 있다.따라서 API 서버가 공통적인 API를 가지더라도, 다르게 제공하는 엔드포인트를 통해 다른 서비스 혹은 클라이언트를 위한 API로 서비스가 가능하다. 메시지/헤더 기반 라우팅메시지나 헤더의 내용을 기반으로 API 라우팅을 할 수 있다. 특히 글로벌 단위로 배포되는 시스템에서, 데이터 센터 간 메시지 라우팅 시 유용하게 사용될 수 있다. 라우팅 정보 추출 시, API 게이트웨이가 메시지를 파싱하는 데에 많은 파워가 소모될 수 있다는 점을 주의해야 한다. API 게이트웨이가 REST API 형태의 엔드포인트를 클라이언트에게 제공한다면, 라우팅 정보를 HTTP 헤더 부분에 넣고, API 게이트웨이는 헤더만 파싱하여 라우팅 정보를 추출, API 서버로는 HTTP 바디를 포워딩 하는 용도로만 사용하여 API 게이트웨이의 부하를 줄여주는 것이 좋다. Mediation메디에이션 기능은, 클라이언트에서 호출하는 요청과 API 서버가 제공하는 API의 스펙에 차이가 발생할 때, 이를 중간에서 중재해주는 기능을 이야기한다. 메시지 포맷 변환메시지 포맷 변환은 클라이언트와 서버가 서로 다른 메시지 포맷을 채택하고 있을 때, 이를 적절하게 변환시켜주는 기능을 의미한다. 프로토콜 변환다양한 서비스 및 클라이언트를 지원하게 되면, 각 서비스 및 클라이언트가 다른 통신 프로토콜을 사용해야 하는 경우가 생길 수 있다.특히, 내부 API는 gRPC와 같은 차세대 프로토콜을 이용해 구현하면서도, 외부로는 REST API를 통해 서비스함으로써 내부 API의 성능을 올리면서도 범용성을 높이는 것이 가능하다. AggregationAgregation이란 서로 다른 API를 묶어서 하나의 API로 제공하는 것을 의미한다. 예로, 치킨을 조리하고 포장하는 작업을 하나의 API로 제공하려 한다고 해보자. 양계장에서 닭 배달 조리 방식 선정 (튀기기 대 굽기) 포장 치킨의 조리부터 포장까지 마치기 위해서 위와 같은 3개의 서로 다른 서비스의 API를 호출해야 한다고 해보자. 이를 API 게이트웨이에서 aggregation 한다면 다음과 같은 형태로 구현할 수 있다. 다만, 과도한 aggregation은 API 게이트웨이에 큰 부담을 줄 위험이 있다. 이와 같은 문제를 해결하기 위해서, 여러 API를 조합하는 목적의 mediation API 서버 계층을 도입할 수 있다. References 조대협의 블로그: 대용량 웹서비스를 위한 마이크로 서비스 아키텍쳐의 이해 조대협의 블로그: MSA 아키텍쳐 구현을 위한 API 게이트웨이의 이해 (API GATEWAY) API 게이트웨이 패턴과 클라이언트-마이크로 서비스 간 직접 통신","link":"/2019/09/22/api-gateway/"}],"tags":[{"name":"독후감","slug":"독후감","link":"/tags/%EB%8F%85%ED%9B%84%EA%B0%90/"},{"name":"프로타고라스","slug":"프로타고라스","link":"/tags/%ED%94%84%EB%A1%9C%ED%83%80%EA%B3%A0%EB%9D%BC%EC%8A%A4/"},{"name":"플라톤","slug":"플라톤","link":"/tags/%ED%94%8C%EB%9D%BC%ED%86%A4/"},{"name":"범우","slug":"범우","link":"/tags/%EB%B2%94%EC%9A%B0/"},{"name":"영화감상","slug":"영화감상","link":"/tags/%EC%98%81%ED%99%94%EA%B0%90%EC%83%81/"},{"name":"프랑스","slug":"프랑스","link":"/tags/%ED%94%84%EB%9E%91%EC%8A%A4/"},{"name":"피어스 브로스넌","slug":"피어스-브로스넌","link":"/tags/%ED%94%BC%EC%96%B4%EC%8A%A4-%EB%B8%8C%EB%A1%9C%EC%8A%A4%EB%84%8C/"},{"name":"제라드 버틀러","slug":"제라드-버틀러","link":"/tags/%EC%A0%9C%EB%9D%BC%EB%93%9C-%EB%B2%84%ED%8B%80%EB%9F%AC/"},{"name":"제이미 폭스","slug":"제이미-폭스","link":"/tags/%EC%A0%9C%EC%9D%B4%EB%AF%B8-%ED%8F%AD%EC%8A%A4/"},{"name":"황정민","slug":"황정민","link":"/tags/%ED%99%A9%EC%A0%95%EB%AF%BC/"},{"name":"무라카미 하루키","slug":"무라카미-하루키","link":"/tags/%EB%AC%B4%EB%9D%BC%EC%B9%B4%EB%AF%B8-%ED%95%98%EB%A3%A8%ED%82%A4/"},{"name":"민음사","slug":"민음사","link":"/tags/%EB%AF%BC%EC%9D%8C%EC%82%AC/"},{"name":"인공지능","slug":"인공지능","link":"/tags/%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5/"},{"name":"Data Structure","slug":"Data-Structure","link":"/tags/Data-Structure/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"BST","slug":"BST","link":"/tags/BST/"},{"name":"액션","slug":"액션","link":"/tags/%EC%95%A1%EC%85%98/"},{"name":"콜린 퍼스","slug":"콜린-퍼스","link":"/tags/%EC%BD%9C%EB%A6%B0-%ED%8D%BC%EC%8A%A4/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"HackerRank","slug":"HackerRank","link":"/tags/HackerRank/"},{"name":"Vue.js","slug":"Vue-js","link":"/tags/Vue-js/"},{"name":"Typescript","slug":"Typescript","link":"/tags/Typescript/"},{"name":"Tutorial","slug":"Tutorial","link":"/tags/Tutorial/"},{"name":"번역","slug":"번역","link":"/tags/%EB%B2%88%EC%97%AD/"},{"name":"Microservice","slug":"Microservice","link":"/tags/Microservice/"},{"name":"Architecture","slug":"Architecture","link":"/tags/Architecture/"},{"name":"API Gateway","slug":"API-Gateway","link":"/tags/API-Gateway/"}],"categories":[{"name":"Book","slug":"Book","link":"/categories/Book/"},{"name":"Movie","slug":"Movie","link":"/categories/Movie/"},{"name":"Programming","slug":"Programming","link":"/categories/Programming/"},{"name":"Frontend","slug":"Programming/Frontend","link":"/categories/Programming/Frontend/"},{"name":"Data Structure","slug":"Programming/Data-Structure","link":"/categories/Programming/Data-Structure/"},{"name":"Algorithm","slug":"Programming/Algorithm","link":"/categories/Programming/Algorithm/"},{"name":"Microservice","slug":"Programming/Microservice","link":"/categories/Programming/Microservice/"}]}